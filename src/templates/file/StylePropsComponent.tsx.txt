import {
  forwardRef,
  ReactNode,
  RefAttributes,
  HTMLAttributes,
  ForwardedRef,
} from "react";
import { kebabCase } from "lodash";
import {
  css as emotionCss,
  type Interpolation,
  type Theme,
  ClassNames,
} from "@emotion/react";

import cssPropertyMap, { CSSPropertyMap } from "./cssPropertyMap";
import { allTags, voidTags } from "./htmlTagData";
import { specialCaseList, specialCaseMap } from "./special-cases";

/**
 * List of valid CSS property names
 */
const cssPropertyNames = Object.keys(cssPropertyMap);

/**
 * Creates a closure that can check if a given value belongs to a given array
 * Uses a Set for faster lookup
 */
function makeInclusionChecker<T>(array: T[] | readonly T[]) {
  const asSet = new Set<T>(array);
  return (value: T) => asSet.has(value);
}

/**
 * A union of string literal types where each string literal represents a valid HTML tag.
 */
export type AllowedTag = (typeof allTags)[number];

/**
 * A closure to check if a string is a void (no children) tag.
 */
const voidTagsIC = makeInclusionChecker<(typeof voidTags)[number]>([
  ...voidTags,
]);

/**
 * A closure to check if a string is a CSS property name.
 */
const cssPropertyNamesIC = makeInclusionChecker(cssPropertyNames);

/**
 * A closure to check if a particular tag is a special case.
 */
const specialCaseIC = makeInclusionChecker(specialCaseList);

function getOriginalFromMangled(name: string): string {
  if (name.startsWith("css")) {
    const withoutCss = name.slice(3);
    if (withoutCss.length === 1) {
      return withoutCss.toLowerCase();
    }
    if (withoutCss.length > 1) {
      return withoutCss.charAt(0).toLowerCase() + withoutCss.slice(1);
    }
    return name;
  }
  return name;
}

/**
 * The props present on a style props component.
 */
export type StylePropsComponentProps<T extends HTMLElement> =
  // Aria and DOM
  HTMLAttributes<T> &
    // Support for React's ref system
    RefAttributes<T> & {
      // May be redundant
      // But we want to make it clear that this component is compatible with ref forwarding
      ref?: ForwardedRef<T>;
      // Optional children of the component
      // This supports the JSX syntax
      // Using ReactNode is preferable (as of 2024) to ReactElement or JSX.element
      // Particularly, around string literal children or falsy children
      children?: ReactNode | ReactNode[];
      // Capture Emotion's css prop when passed to this component.
      // Note: Emotion's css prop accepts many forms (objects, arrays, functions, etc),
      // so prefer Interpolation<Theme> over SerializedStyles.
      css?: Interpolation<Theme>;
    } & {
      // A collection of style props and their values
      [K in keyof CSSPropertyMap]?: CSSPropertyMap[K];
    };

/**
 * The style props component
 *
 * Supports ref forwarding, so each component behaves identical to their plain HTML counterpart
 * with regards to React's ref system.
 *
 * Note: The user of this library should never use this component directly.
 */
export default forwardRef<
  HTMLElement,
  StylePropsComponentProps<HTMLElement> & {
    /**
     * The html tag to use in `createElement`
     */
    tag: AllowedTag;
  }
>(function StylePropsComponent(
  {
    /**
     * Children to be rendered within the component
     */
    children,
    /**
     * The html tag to use in `createElement`
     */
    tag,
    /**
     * Forwarded Emotion css prop from callers, if any
     */
    css: existingCss,
    /**
     * This will contain a combination of regular props and style props
     */
    ...rest
  },
  /**
   * A reference to an enhanced `ref` prop that enables ref forwarding
   */
  ref
) {
  /**
   * The portion of the remaining props that are interpreted as style props
   */
  const restPropsStyleProps = {} as any;

  /**
   * The portion of the remaining props that are interpreted as regular props
   *
   * NOTE:
   * - This will include className if the user passes it.
   * - It will also include data-*, aria-*, onClick, etc.
   */
  const restPropsRegularProps = {} as any;

  // Normal case
  if (!specialCaseIC(tag as (typeof specialCaseList)[number])) {
    // For each prop in `rest`
    for (const [propName, propValue] of Object.entries(rest)) {
      // If the prop is a CSS property then add to style props, otherwise add to regular props
      if (cssPropertyNamesIC(propName)) {
        restPropsStyleProps[propName] = propValue;
      } else {
        restPropsRegularProps[propName] = propValue;
      }
    }
    // Special case
  } else {
    // Identify the list of css attributes that can conflict in the special case
    const specialCaseAttributeList =
      specialCaseMap[tag as keyof typeof specialCaseMap];
    // Enhance performance by creating a Set for faster lookup
    const specialCaseAttributeListIC = makeInclusionChecker(
      specialCaseAttributeList
    );
    // For each prop in `rest`
    for (const [propName, propValue] of Object.entries(rest)) {
      // The css property names also include the special case attributes
      if (cssPropertyNamesIC(propName)) {
        if (
          specialCaseAttributeListIC(
            getOriginalFromMangled(
              propName
            ) as (typeof specialCaseAttributeList)[number]
          )
        ) {
          // If the prop follows the special case naming convention such as "cssWidth" or "cssHeight"
          if (getOriginalFromMangled(propName) !== propName) {
            restPropsStyleProps[getOriginalFromMangled(propName)] = propValue;
          } else {
            // Must be a regular prop
            // In the special cases this means that attributes such as "width" and "height"
            // would be applied preferentially to the regular props
            // and we would need to add the "css" prefix if we explicitly want a style prop
            restPropsRegularProps[propName] = propValue;
          }
        } else {
          // If not a special case attribute we can confidently add it to style props
          restPropsStyleProps[propName] = propValue;
        }
      } else {
        // For sure is regular prop
        restPropsRegularProps[propName] = propValue;
      }
    }
  }

    const {
    className: incomingClassName,
    ...restPropsRegularPropsSansClassName
  } = restPropsRegularProps as { className?: string };

  /**
   * Compile CSS source code compatible with Emotion CSS
   */
  const stylePropsEntries = Object.entries(restPropsStyleProps).filter(
    ([, value]) =>
      value !== undefined &&
      value !== null &&
      value !== false &&
      (typeof value === "string" || typeof value === "number")
  );

  const stylePropsString =
    stylePropsEntries.length === 0
      ? ""
      : `\n\n${stylePropsEntries
          .map(([key, value]) => `${kebabCase(key)}: ${String(value)};`)
          .join("\n")}\n\n`;

  /**
   * Convert generated style-props CSS into an Emotion style block,
   * then compose with any incoming css prop.
   */
  const hasGeneratedCss = stylePropsString.length > 0;
  const hasIncomingCss = existingCss !== undefined;

  const mergedCss: Interpolation<Theme> | Interpolation<Theme>[] | undefined =
    hasGeneratedCss && hasIncomingCss
      ? [emotionCss`${stylePropsString}`, existingCss]
      : hasGeneratedCss
        ? emotionCss`${stylePropsString}`
        : hasIncomingCss
          ? existingCss
          : undefined;

  return (
    <ClassNames>
      {({ css, cx }) => {
        const mergedClassName = cx(
          incomingClassName,
          mergedCss ? css(mergedCss) : undefined
        );

        return (
<< RETURN_CONDITIONAL_STATEMENT >>
          <></>
        );
      }}
    </ClassNames>
  );
});
